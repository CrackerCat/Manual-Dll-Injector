#include "injector.h"

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class kuoumjv {
public:
	bool nkbqfvubkrwxwhi;
	double jomzktz;
	kuoumjv();
	double ceyrsxfazlavojwc(double rlakyoqxfkhhuq);
	void cxwkmzbzcoabdsi(bool uehjgtb, bool wohbfdrtwfeoo, string jqnxivwblh);
	int vxtobljiazpfotpuxiwj();
	string lepehanytzvproatwkmpvq(bool kirukrqmxfavp, string jgafrqtp, bool ucfmokud);
	string cfiscbhejgjxjpsntfjeojo(double ogtdg, bool xdxixzkc, string ayixbcav, int cfmfw, double nnnwnmitvrhrgl, int nnixaevvrexxsj, int tythhoxapezwk, bool qlskud, string pnbfhisy);

protected:
	int crriatmjml;
	bool nsjstoawa;
	string mrfipmf;
	double tkshottfcfd;
	bool lmweokp;

	void znkxtmpixevskvp(int pgmxqxci);

private:
	int hokrbcifxmahp;
	string cusubfnifwgrr;
	double foecfvkunivlmo;
	int acalkfzu;

	string jjrwhzfjsjokxdbsqotltz(int swyhzqwwqvb, int hjcyapcof, string ifrjqzrzw, string dwciiqjmzd, double cfysncmpgkus, string mhokv);
	int tvurkjqwhgkhxy(bool yjczoqb, bool nyozsg);
	void pmeikmqdulvqdceytx(string ckabnmqmepyrvn, bool bwhjznbbgqz, double nliogjwjxhz, int shynxfkn, double uaxmoudbd, bool vcqugtrv, double bpbmmdptuhff, double bllejqifgbhfyrr, int nhancawpkvz);
	double miacycbmhonfyzr(int pfsiild, double tjzhwps, bool hukht, bool dzddnkawtrxrh);
	string vnjvywqzox();

};


string kuoumjv::jjrwhzfjsjokxdbsqotltz(int swyhzqwwqvb, int hjcyapcof, string ifrjqzrzw, string dwciiqjmzd, double cfysncmpgkus, string mhokv) {
	int pfdikwhaxjd = 888;
	int dyalirpfsxomqb = 626;
	string kjcofdied = "ypdxcqderziagqpqdphahdkmqvvhirxrxowkalomamlvevqyxsppvwru";
	string lohllnq = "kktxwtsftamlbgizbjgsppqxdxafvuntpniktcjzzsmafvlozc";
	bool jnguhhitdp = true;
	bool umbsepvyrmv = true;
	string fwkzz = "htw";
	string dnqfz = "eiauecnmousgbflpubantvfgdcczozchmrbjbwgwcyjpsxkpnmvbhlzxectsqcfambejt";
	int cpehvxjaq = 239;
	return string("mmxrnmcwyruaz");
}

int kuoumjv::tvurkjqwhgkhxy(bool yjczoqb, bool nyozsg) {
	int hkuinsfyadchqbt = 1945;
	string mfdnlppjfgzgj = "gofdkrekjiubawdrnohybwziztduxvmmpanhcbzxyapinqjfimyftlaxzmau";
	int numyhsw = 4;
	double cqukaxraiznvfm = 79961;
	double eykrx = 34595;
	double wlkaqiax = 9310;
	int cfkbgr = 3946;
	double vixokjmoui = 36425;
	int poviraseacaagbf = 3901;
	int nixvnnawuhk = 4005;
	if (9310 == 9310) {
		int golfwuun;
		for (golfwuun = 26; golfwuun > 0; golfwuun--) {
			continue;
		}
	}
	if (4 != 4) {
		int ceqgv;
		for (ceqgv = 5; ceqgv > 0; ceqgv--) {
			continue;
		}
	}
	if (4 != 4) {
		int gilqvcwclw;
		for (gilqvcwclw = 78; gilqvcwclw > 0; gilqvcwclw--) {
			continue;
		}
	}
	return 32866;
}

void kuoumjv::pmeikmqdulvqdceytx(string ckabnmqmepyrvn, bool bwhjznbbgqz, double nliogjwjxhz, int shynxfkn, double uaxmoudbd, bool vcqugtrv, double bpbmmdptuhff, double bllejqifgbhfyrr, int nhancawpkvz) {
	bool qxjshkcfvn = false;
	double shccubo = 71285;
	bool ekoeqfxhwzuilff = true;
	bool pwzornkxn = false;
	if (71285 != 71285) {
		int zuus;
		for (zuus = 32; zuus > 0; zuus--) {
			continue;
		}
	}
	if (71285 != 71285) {
		int sgqnowiiyl;
		for (sgqnowiiyl = 98; sgqnowiiyl > 0; sgqnowiiyl--) {
			continue;
		}
	}
	if (false == false) {
		int kxrewdibv;
		for (kxrewdibv = 64; kxrewdibv > 0; kxrewdibv--) {
			continue;
		}
	}

}

double kuoumjv::miacycbmhonfyzr(int pfsiild, double tjzhwps, bool hukht, bool dzddnkawtrxrh) {
	double arzmbuq = 23663;
	string mikixmsaask = "nwqfoyebqyqhcftuf";
	if (string("nwqfoyebqyqhcftuf") == string("nwqfoyebqyqhcftuf")) {
		int aiuplafg;
		for (aiuplafg = 100; aiuplafg > 0; aiuplafg--) {
			continue;
		}
	}
	if (23663 != 23663) {
		int lvkrhwcak;
		for (lvkrhwcak = 38; lvkrhwcak > 0; lvkrhwcak--) {
			continue;
		}
	}
	if (string("nwqfoyebqyqhcftuf") == string("nwqfoyebqyqhcftuf")) {
		int abxmyee;
		for (abxmyee = 93; abxmyee > 0; abxmyee--) {
			continue;
		}
	}
	if (23663 != 23663) {
		int jmtghytjw;
		for (jmtghytjw = 30; jmtghytjw > 0; jmtghytjw--) {
			continue;
		}
	}
	return 59252;
}

string kuoumjv::vnjvywqzox() {
	bool fdihiewg = true;
	bool postdtxujxavdh = true;
	int uupngkkknjeesfr = 8159;
	int xgntpzbndawvqib = 4577;
	string xjjcozx = "ilhdfanypatwhxmybzmiyasciwaokzlihdiyfgmyneeamcwqqzhvkasnmaojhncjkdiajtqfgbjer";
	bool tnmifxz = false;
	return string("droowgjmbzoqmd");
}

void kuoumjv::znkxtmpixevskvp(int pgmxqxci) {
	double nxxyobsuysvcbw = 35558;
	int dcxqo = 226;
	int bfrkw = 1054;
	if (226 != 226) {
		int ukuuras;
		for (ukuuras = 69; ukuuras > 0; ukuuras--) {
			continue;
		}
	}
	if (1054 != 1054) {
		int bmppt;
		for (bmppt = 12; bmppt > 0; bmppt--) {
			continue;
		}
	}
	if (35558 != 35558) {
		int ajrgai;
		for (ajrgai = 26; ajrgai > 0; ajrgai--) {
			continue;
		}
	}

}

double kuoumjv::ceyrsxfazlavojwc(double rlakyoqxfkhhuq) {
	string anpkc = "gylqkbepheyelnfogohegzpgvjfwtkdfabgruiiznjybthlrofpebix";
	string asnogjzfkvavicm = "vvftrcdhyxitynwvfcezoznafzhgxnrekhtpolvgrtjyltjagckyiaqkydjkxuyjhjgwkfcxzd";
	int uttax = 6634;
	double fokdqg = 2742;
	double kksyqivbdgd = 20124;
	int cydtka = 4074;
	double ltvbuugpjhx = 6174;
	double achgnr = 34127;
	int kovpayrcbnqvi = 4429;
	return 14020;
}

void kuoumjv::cxwkmzbzcoabdsi(bool uehjgtb, bool wohbfdrtwfeoo, string jqnxivwblh) {
	string fmperfolt = "otytowpznumofktwbujzlqwphqzeejukypihoyrrvni";
	double fhilliskbmvtpgd = 47926;
	string akrlhjxxgrcm = "m";
	int czzxqsissihzbgo = 2453;
	int sxjlziu = 1593;

}

int kuoumjv::vxtobljiazpfotpuxiwj() {
	int svdyqcxhkddpynw = 5097;
	bool hmrfcowupedj = true;
	int mhzvzbsdr = 1211;
	string irwvzdwtq = "jbekwylkmzrrkitxiwbabjmiumkkgylmpsgbzlglgfpzxurnnvotnzkdwzzusqumfocewlejwwolsfdzvjwrywhwsjqrgilb";
	int clqjbzm = 5041;
	if (string("jbekwylkmzrrkitxiwbabjmiumkkgylmpsgbzlglgfpzxurnnvotnzkdwzzusqumfocewlejwwolsfdzvjwrywhwsjqrgilb") != string("jbekwylkmzrrkitxiwbabjmiumkkgylmpsgbzlglgfpzxurnnvotnzkdwzzusqumfocewlejwwolsfdzvjwrywhwsjqrgilb")) {
		int chdgfzc;
		for (chdgfzc = 0; chdgfzc > 0; chdgfzc--) {
			continue;
		}
	}
	if (true != true) {
		int gxwz;
		for (gxwz = 5; gxwz > 0; gxwz--) {
			continue;
		}
	}
	if (5041 == 5041) {
		int dausvaqu;
		for (dausvaqu = 33; dausvaqu > 0; dausvaqu--) {
			continue;
		}
	}
	if (true != true) {
		int paglmlu;
		for (paglmlu = 31; paglmlu > 0; paglmlu--) {
			continue;
		}
	}
	if (1211 != 1211) {
		int zcqwprl;
		for (zcqwprl = 44; zcqwprl > 0; zcqwprl--) {
			continue;
		}
	}
	return 98402;
}

string kuoumjv::lepehanytzvproatwkmpvq(bool kirukrqmxfavp, string jgafrqtp, bool ucfmokud) {
	double xfnczfsvnwweqy = 23766;
	int hwxvvmwwaqz = 190;
	double amplvqnyc = 37467;
	if (190 != 190) {
		int dbnaz;
		for (dbnaz = 81; dbnaz > 0; dbnaz--) {
			continue;
		}
	}
	if (37467 != 37467) {
		int nyedza;
		for (nyedza = 35; nyedza > 0; nyedza--) {
			continue;
		}
	}
	if (190 == 190) {
		int wryun;
		for (wryun = 75; wryun > 0; wryun--) {
			continue;
		}
	}
	return string("cwrlmpqgdpeejjghd");
}

string kuoumjv::cfiscbhejgjxjpsntfjeojo(double ogtdg, bool xdxixzkc, string ayixbcav, int cfmfw, double nnnwnmitvrhrgl, int nnixaevvrexxsj, int tythhoxapezwk, bool qlskud, string pnbfhisy) {
	double edvvjwgzr = 12728;
	double tqoxgoutivarji = 3675;
	string wdzwmqobw = "ksyxspfwdselrcvpfhqhybcfkerwalgdyeswrsezbhqqsbplftlimodbvysy";
	double onmzsmf = 38803;
	string sxwffhsudim = "lldkxutwmrbpsdamdaybqgmypgozqpirfw";
	int crmnhzgeljpfjy = 4730;
	string psivksiyrhq = "dkxodrplehedoovmopkbcu";
	if (3675 != 3675) {
		int memiubzklm;
		for (memiubzklm = 92; memiubzklm > 0; memiubzklm--) {
			continue;
		}
	}
	return string("fpc");
}

kuoumjv::kuoumjv() {
	this->ceyrsxfazlavojwc(50589);
	this->cxwkmzbzcoabdsi(false, true, string("gvwfazgiufqzoznbugrqdygkadmltakfncbggdjurrbqaznhhzhefsmpkdcyyeghqmoibnplcdpfvav"));
	this->vxtobljiazpfotpuxiwj();
	this->lepehanytzvproatwkmpvq(false, string("woasysuzjmzkmmlrvkghkxczofdlquvjkfvh"), true);
	this->cfiscbhejgjxjpsntfjeojo(18210, false, string("mtzyp"), 1537, 20774, 3630, 7060, false, string("mhrxpwlsklypgvyaxptqyjnmrmlpuwznpxjmdplbphkdrpoxsbwefndqllzyhuyo"));
	this->znkxtmpixevskvp(252);
	this->jjrwhzfjsjokxdbsqotltz(5757, 5001, string("cyfefizbfnzndjiwbri"), string("mjkzxnwkdeivfcwditvwfvigvlarizboakdzmexbszxjuryamicvidodzpdqysfywoekxbbhbjlftmyoxwwrwpcyki"), 79391, string("rqigvcatvnwdmkonhxdyqrnqgyticxlcvytvonxgzqbrltfjtvgguhrdcpfqlrfmouytpzyezxbtiryqaeomjyiwyn"));
	this->tvurkjqwhgkhxy(false, true);
	this->pmeikmqdulvqdceytx(string("rhzurmhdejktqhcotiraypztzfrjosxtqjixllqcwbjjipptgqjlrjeopukokshpdbbpxahntblssk"), true, 44564, 2337, 19672, true, 16496, 77375, 597);
	this->miacycbmhonfyzr(645, 2986, false, true);
	this->vnjvywqzox();
}



void __stdcall Shellcode(MANUAL_MAPPING_DATA * pData);

bool ManualMap(HANDLE hProc, const char * szDllFile)
{
	BYTE *					pSrcData = nullptr;
	IMAGE_NT_HEADERS *		pOldNtHeader = nullptr;
	IMAGE_OPTIONAL_HEADER * pOldOptHeader = nullptr;
	IMAGE_FILE_HEADER *		pOldFileHeader = nullptr;
	BYTE *					pTargetBase = nullptr;

	if (GetFileAttributesA(szDllFile)==INVALID_FILE_ATTRIBUTES)
	{
		printf("File doesn't exist\n");
		return false;
	}

	std::ifstream File(szDllFile, std::ios::binary | std::ios::ate);

	if (File.fail())
	{
		printf("Opening the file failed: %X\n", (DWORD)File.rdstate());
		File.close();
		return false;
	}

	auto FileSize = File.tellg();
	if (FileSize < 0x1000)
	{
		printf("Filesize is invalid.\n");
		File.close();
		return false;
	}

	pSrcData = new BYTE[static_cast<UINT_PTR>(FileSize)];
	if (!pSrcData)
	{
		printf("Memory allocating failed\n");
		File.close();
		return false;
	}

	File.seekg(0, std::ios::beg);
	File.read(reinterpret_cast<char*>(pSrcData), FileSize);
	File.close();

	if (reinterpret_cast<IMAGE_DOS_HEADER*>(pSrcData)->e_magic != 0x5A4D) //"MZ"
	{
		printf("Invalid file\n");
		delete[] pSrcData;
		return false;
	}

	pOldNtHeader = reinterpret_cast<IMAGE_NT_HEADERS*>(pSrcData + reinterpret_cast<IMAGE_DOS_HEADER*>(pSrcData)->e_lfanew);
	pOldOptHeader = &pOldNtHeader->OptionalHeader;
	pOldFileHeader = &pOldNtHeader->FileHeader;

#ifdef _WIN64
	if (pOldFileHeader->Machine != IMAGE_FILE_MACHINE_AMD64)
	{
		printf("Invalid platform\n");
		delete[] pSrcData;
		return false;
	}
#else
	if (pOldFileHeader->Machine != IMAGE_FILE_MACHINE_I386)
	{
		printf("Invalid platform\n");
		delete[] pSrcData;
		return false;
	}
#endif

	pTargetBase = reinterpret_cast<BYTE*>(VirtualAllocEx(hProc, reinterpret_cast<void*>(pOldOptHeader->ImageBase), pOldOptHeader->SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE));
	if (!pTargetBase)
	{
		pTargetBase = reinterpret_cast<BYTE*>(VirtualAllocEx(hProc, nullptr, pOldOptHeader->SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE));
		if (!pTargetBase)
		{
			printf("Memory allocation failed (ex) 0x%X\n", GetLastError());
			delete[] pSrcData;
			return false;
		}
	}

	MANUAL_MAPPING_DATA data{ 0 };
	data.pLoadLibraryA = LoadLibraryA;
	data.pGetProcAddress = reinterpret_cast<f_GetProcAddress>(GetProcAddress);

	auto * pSectionHeader = IMAGE_FIRST_SECTION(pOldNtHeader);
	for (UINT i = 0; i != pOldFileHeader->NumberOfSections; ++i, ++pSectionHeader)
	{
		if (pSectionHeader->SizeOfRawData)
		{
			if (!WriteProcessMemory(hProc, pTargetBase + pSectionHeader->VirtualAddress, pSrcData + pSectionHeader->PointerToRawData, pSectionHeader->SizeOfRawData, nullptr))
			{
				printf("Can't map sections: 0x%x\n", GetLastError());
				delete[] pSrcData;
				VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
				return false;
			}
		}
	}

	memcpy(pSrcData, &data, sizeof(data));
	WriteProcessMemory(hProc, pTargetBase, pSrcData, 0x1000, nullptr);

	delete[] pSrcData;

	void * pShellcode = VirtualAllocEx(hProc, nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pShellcode)
	{
		printf("Memory allocation failed (1) (ex) 0x%X\n", GetLastError());
		VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
		return false;
	}

	WriteProcessMemory(hProc, pShellcode, Shellcode, 0x1000, nullptr);

	HANDLE hThread = CreateRemoteThread(hProc, nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(pShellcode), pTargetBase, 0, nullptr);
	if (!hThread)
	{
		printf("Thread creation failed 0x%X\n", GetLastError());
		VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
		VirtualFreeEx(hProc, pShellcode, 0, MEM_RELEASE);
		return false;
	}

	CloseHandle(hThread);

	HINSTANCE hCheck = NULL;
	while (!hCheck)
	{
		MANUAL_MAPPING_DATA data_checked{ 0 };
		ReadProcessMemory(hProc, pTargetBase, &data_checked, sizeof(data_checked), nullptr);
		hCheck = data_checked.hMod;
		Sleep(10);
	}

	VirtualFreeEx(hProc, pShellcode, 0, MEM_RELEASE);

	return true;
}

#define RELOC_FLAG32(RelInfo) ((RelInfo >> 0x0C) == IMAGE_REL_BASED_HIGHLOW)
#define RELOC_FLAG64(RelInfo) ((RelInfo >> 0x0C) == IMAGE_REL_BASED_DIR64)

#ifdef _WIN64
#define RELOC_FLAG RELOC_FLAG64
#else
#define RELOC_FLAG RELOC_FLAG32
#endif

void __stdcall Shellcode(MANUAL_MAPPING_DATA * pData)
{
	if (!pData)
		return;

	BYTE * pBase = reinterpret_cast<BYTE*>(pData);
	auto * pOpt = &reinterpret_cast<IMAGE_NT_HEADERS*>(pBase + reinterpret_cast<IMAGE_DOS_HEADER*>(pData)->e_lfanew)->OptionalHeader;

	auto _LoadLibraryA = pData->pLoadLibraryA;
	auto _GetProcAddress = pData->pGetProcAddress;
	auto _DllMain = reinterpret_cast<f_DLL_ENTRY_POINT>(pBase + pOpt->AddressOfEntryPoint);

	BYTE * LocationDelta = pBase - pOpt->ImageBase;
	if (LocationDelta)
	{
		if (!pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size)
			return;

		auto * pRelocData = reinterpret_cast<IMAGE_BASE_RELOCATION*>(pBase + pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
		while (pRelocData->VirtualAddress)
		{
			UINT AmountOfEntries = (pRelocData->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
			WORD * pRelativeInfo = reinterpret_cast<WORD*>(pRelocData + 1);

			for (UINT i = 0; i != AmountOfEntries; ++i, ++pRelativeInfo)
			{
				if (RELOC_FLAG(*pRelativeInfo))
				{
					UINT_PTR * pPatch = reinterpret_cast<UINT_PTR*>(pBase + pRelocData->VirtualAddress + ((*pRelativeInfo) & 0xFFF));
					*pPatch += reinterpret_cast<UINT_PTR>(LocationDelta);
				}
			}
			pRelocData = reinterpret_cast<IMAGE_BASE_RELOCATION*>(reinterpret_cast<BYTE*>(pRelocData) + pRelocData->SizeOfBlock);
		}
	}

	if (pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size)
	{
		auto * pImportDescr = reinterpret_cast<IMAGE_IMPORT_DESCRIPTOR*>(pBase + pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
		while (pImportDescr->Name)
		{
			char * szMod = reinterpret_cast<char*>(pBase + pImportDescr->Name);
			HINSTANCE hDll = _LoadLibraryA(szMod);

			ULONG_PTR * pThunkRef = reinterpret_cast<ULONG_PTR*>(pBase + pImportDescr->OriginalFirstThunk);
			ULONG_PTR * pFuncRef = reinterpret_cast<ULONG_PTR*>(pBase + pImportDescr->FirstThunk);

			if (!pThunkRef)
				pThunkRef = pFuncRef;

			for (; *pThunkRef; ++pThunkRef, ++pFuncRef)
			{
				if (IMAGE_SNAP_BY_ORDINAL(*pThunkRef))
				{
					*pFuncRef = _GetProcAddress(hDll, reinterpret_cast<char*>(*pThunkRef & 0xFFFF));
				}
				else
				{
					auto * pImport = reinterpret_cast<IMAGE_IMPORT_BY_NAME*>(pBase + (*pThunkRef));
					*pFuncRef = _GetProcAddress(hDll, pImport->Name);
				}
			}
			++pImportDescr;
		}
	}

	if (pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size)
	{
		auto * pTLS = reinterpret_cast<IMAGE_TLS_DIRECTORY*>(pBase + pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
		auto * pCallback = reinterpret_cast<PIMAGE_TLS_CALLBACK*>(pTLS->AddressOfCallBacks);
		for (; pCallback && *pCallback; ++pCallback)
			(*pCallback)(pBase, DLL_PROCESS_ATTACH, nullptr);
	}

	_DllMain(pBase, DLL_PROCESS_ATTACH, nullptr);

	pData->hMod = reinterpret_cast<HINSTANCE>(pBase);
}